#include <TimeLib.h>
#include <WiFiManager.h>
#include <ESP8266WiFi.h>

#include <ArduinoJson.h>
#include <ArduinoJson.hpp>

#include "thingProperties.h"

const int RESET_PIN_Due = 5;
//declare func
void resetArduino();

//#define ARDUINOJSON_ENABLE_PROGMEM 0

unsigned long previousMillis_status = 0;
unsigned long previousMillis_err = 0;
unsigned long previousMillis_light_fan = 0;
const unsigned long statusInterval = 600000; // Interval for sending the status message (10 minutes in milliseconds)
const unsigned long tempInterval = 660000;   // Interval for checking temperature is working or not (11 minutes in milliseconds)

unsigned long systemStartTime = 0;  // Variable to store the system start time in milliseconds


unsigned long previousSending = 0;
const unsigned long eventTime_Sending = 5000; // interval in ms
const unsigned long eventTime_light_fan = 30000; // interval in ms

WiFiManager wm;


/* 
  Sketch generated by the Arduino IoT Cloud Thing "NodeMCU Readings"
  https://create.arduino.cc/cloud/things/c3a1bfd6-af7f-4462-a475-4239533d1aad 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String fullMoistureOutput;
  String systemStatus;
  String systemUpTime;
  float CO2;
  float electric_Conductivity_Microsiemens_per_centimeter;
  float humidity;
  float light_Intensity;
  float pressure_hectoPascals_hPa;
  float temperature;
  float total_Dissolved_Solids_PPM;
  float VOC;
  int air_Quality_Index;
  int cycle_Duration;
  int iAQ_AC;
  int pump_Duration_Mins;
  int rootsMoisturePercent;
  CloudSchedule pumpStatus_t;
  bool dueReset;
  bool fanStatus_real;
  bool fanSwitch;
  bool lightIsOFF;
  bool light_status;
  bool pumpStatus;
  bool pumpStatus2;
  bool waterLevel;
  CloudTime time_read;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/



/**
 * @brief Checks if any of the sensor values have changed compared to the previously stored ones
 *
 * @param currentTemp Current temperature value
 * @param currentHumidity Current humidity value
 * @param currentCO2 Current CO2 concentration value
 * @param currentVOC Current volatile organic compound value
 * @param currentRootsMoisturePercent Current roots moisture percentage value
 * @param currentLight_Intensity Current light intensity value
 * @param currentTDS Current Total Dissolved Solids value in Parts Per Million (PPM)
 *
 * @return True if any of the sensor values have changed, False otherwise
 */
 ///
bool checkSensorData(float currentTemp, float currentHumidity, float currentCO2, float currentVOC, float currentRootsMoisturePercent, float currentLight_Intensity, float currentTDS) {
  // Use static memory to store previous sensor readings
  static float previousTemp = 0.0;
  static float previousHumidity = 0.0;
  static float previousCO2 = 0.0;
  static float previousVOC = 0.0;
  static float previousRootsMoisturePercent = 0.0;
  static float previousLight_Intensity = 0.0;
  static float previousTotal_Dissolved_Solids_PPM = 0.0;

  // Check if any of the sensor values have changed
  if (currentTemp != previousTemp || currentHumidity != previousHumidity || currentCO2 != previousCO2 || currentVOC != previousVOC || currentVOC != previousRootsMoisturePercent || currentVOC != previousLight_Intensity || currentVOC != previousTotal_Dissolved_Solids_PPM) {
    // Sensor values have changed, update the previous values
    previousTemp = currentTemp;
    previousHumidity = currentHumidity;
    previousCO2 = currentCO2;
    previousVOC = currentVOC;
    previousRootsMoisturePercent = currentRootsMoisturePercent;
    previousLight_Intensity = currentLight_Intensity;
    previousTotal_Dissolved_Solids_PPM = currentTDS;

    // Indicate that sensor values have changed
    return true;
  } else {
    // No changes in sensor values
    return false;
  }
}

 /**
@brief Convert Unix timestamp to a formatted string representing date and time in AM/PM format

@param unixTime Unix timestamp in seconds
@return Formatted time as a String in the format "YYYY-MM-DD HH:MM AM/PM"
*/
///
String convertUnixTimestamp(unsigned long unixTime) {
  char formattedTime[25]; // Buffer to store formatted time
  tmElements\_t timeInfo; // Structure to hold time elements

  // Convert UNIX timestamp to time elements
  breakTime(unixTime \* 1000, timeInfo); // Convert to milliseconds

  // Determine AM/PM and convert hour to 12-hour format
  int hour = timeInfo.Hour;
  bool isPM = false;
  if (hour >= 12) {
    isPM = true;
    if (hour > 12) {
      hour -= 12;
    }
  }
  if (hour == 0) {
    hour = 12;
  }

  // Format the time as "YYYY-MM-DD HH:MM AM/PM"
  snprintf(formattedTime, sizeof(formattedTime), "%04d-%02d-%02d %02d:%02d %s",
            year(unixTime), month(unixTime), day(unixTime),
            hour, timeInfo.Minute,
            (isPM ? "PM" : "AM"));

  // Return the formatted time as a String
  return String(formattedTime);
}

/**
 * @brief Gets the system uptime in milliseconds
 *
 * @return The system uptime in milliseconds
 */
 ///
unsigned long getSystemUptime() {
  // Subtract the recorded system startup time from the current millisecond count
  // to compute the elapsed time since the system started.
  return millis() - systemStartTime;
}

/**
 * Get the formatted system uptime string
 *
 * This function converts the system uptime in milliseconds to a formatted
 * string showing the time elapsed in days, hours, minutes, and seconds.
 *
 * @return The formatted system uptime as a string
 */
String getFormattedSystemUptime() {
  unsigned long uptime = getSystemUptime();

  // Convert the uptime from milliseconds to seconds, minutes, hours, and days
  unsigned long seconds = uptime / 1000;
  unsigned long minutes = seconds / 60;
  unsigned long hours = minutes / 60;
  unsigned long days = hours / 24;

  // Calculate the remaining hours, minutes, and seconds after accounting for days
  hours %= 24;
  minutes %= 60;
  seconds %= 60;

  // Build the formatted uptime string
  String uptimeString = "";
  uptimeString += days;
  uptimeString += " days, ";
  uptimeString += hours;
  uptimeString += " hours, ";
  uptimeString += minutes;
  uptimeString += " minutes, ";
  uptimeString += seconds;
  uptimeString += " seconds";

  return uptimeString;
}

void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  delay(1500);

  systemStartTime = millis();  // Record the system start time

  pinMode(RESET_PIN_Due, OUTPUT);
  digitalWrite(RESET_PIN_Due, HIGH);

  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);

  // wm.setConfigPortalTimeout(300);
  // //automatically connect using saved credentials if they exist
  // //If connection fails it starts an access point with the specified name
  // if(wm.autoConnect("Farming+", "123456789")){
  //     Serial.println("connected...yeey :)");
  // }
  // else {
  //     Serial.println("Configportal running");
  // }

  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
  //delay(25000);
  systemStatus = "Farming+ is working and WI-FI is connected !";
  temperature = 25;
  humidity = 50;
  Serial.println(WiFi.macAddress());
}


void loop() {
  //wm.process();

  if (temperature != 0 || humidity != 0) {
    // Update values on Arduino Cloud
    ArduinoCloud.update();
  }
  
  if (Serial.available()) {
    StaticJsonDocument<400> doc;
    DeserializationError err = deserializeJson(doc, Serial);

    if (err == DeserializationError::Ok)
    {
      // Print the values
      // (we must use as<T>() to resolve the ambiguity)
      light_Intensity = doc["LUX"].as<float>();
      total_Dissolved_Solids_PPM = doc["tds"].as<float>();
      electric_Conductivity_Microsiemens_per_centimeter = doc["ec"].as<float>();
      temperature = doc["temp"].as<float>();
      humidity = doc["Hum"].as<float>();
      pressure_hectoPascals_hPa = doc["Pr"].as<float>();
      CO2 = doc["Co2"].as<float>();
      air_Quality_Index = doc["IAQ"].as<int>();
      VOC = doc["VOC"].as<float>();
      waterLevel = doc["waterLevelState"].as<int>(); 
      iAQ_AC = doc["IAQ_AC"].as<int>();
      fullMoistureOutput = doc["fullMoistureOutput"].as<String>();
      rootsMoisturePercent = doc["rootsMoisturePercent"].as<int>();
      pumpStatus2 = doc["pumpStatus2"].as<int>();
      cycle_Duration = doc["cycle_Duration"].as<int>();
    }
    else
    {
      // Print error to the "debug" serial port
      Serial.print("deserializeJson() returned ");
      Serial.println(err.c_str());
    }
    // Flush all bytes in the "link" serial port buffer
    while (Serial.available() > 0)
      Serial.read();
  }

  if (pumpStatus_t.isActive() && waterLevel == 1) {
    //do something
    pumpStatus = 1;
  }
  else {
    pumpStatus = 0;
  }
  if (ArduinoCloud.connected()) {
    time_read = ArduinoCloud.getLocalTime();
  }
  
  
  if ((unsigned long)(millis() - previousSending) > eventTime_Sending){
    previousSending = millis();
    //Send duration and status of the pump
    StaticJsonDocument<100> pump_on_dur;
    pump_on_dur["pumpOnDuration"] = pump_Duration_Mins;
    pump_on_dur["pumpStatus"] = pumpStatus;
    pump_on_dur["fanStatus_real"] = fanStatus_real;
    pump_on_dur["light_status"] = light_status;
  
    // Serialize JSON to a string and send it to Arduino Due
    serializeJson(pump_on_dur, Serial);
    //Serial.print(pumpOnDuration);
    previousSending = millis();
  }
  // Update the system status if sufficient time has elapsed
  if ((unsigned long)(millis() - previousMillis_status) > statusInterval) {
    previousMillis_status = millis();
    systemStatus = convertUnixTimestamp(time_read) + " | Farming+ is working and WI-FI is connected!";
    checkSensorData(temperature, humidity, CO2, VOC, rootsMoisturePercent, light_Intensity, total_Dissolved_Solids_PPM);
  }

  // Check for sensor data inconsistency if sufficient time has elapsed
  if ((unsigned long)(millis() - previousMillis_err) > tempInterval) {
    previousMillis_err = millis();
    if (!checkSensorData(temperature, humidity, CO2, VOC, rootsMoisturePercent, light_Intensity, total_Dissolved_Solids_PPM)) {
      // Raise an error because the temperature has not changed in the last 10 minutes
      systemStatus = convertUnixTimestamp(time_read) + " | Warning: Sensor Data have not changed in the last 10 mins - Will RESET the arduino due";
      resetArduino();
    }
  }

  // Get the formatted system uptime
  systemUpTime = getFormattedSystemUptime();
 
 
  if ((unsigned long)(millis() - previousMillis_light_fan) > eventTime_light_fan){
    previousMillis_light_fan = millis();
    //light status
    if (light_Intensity >= 5){
      lightIsOFF = 0;
    }else{
      lightIsOFF = 1;
    }
    //Fan status
    if(fanSwitch == 1 || (temperature >= 35 || humidity >= 85)){
      fanStatus_real = 1;
    }else if (fanSwitch == 0){
      fanStatus_real = 0;
    }

    previousMillis_light_fan = millis();
  }
  
}

/*
  Since PumpDurationMins is READ_WRITE variable, onPumpDurationMinsChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPumpDurationMinsChange()  {
  // Add your code here to act upon PumpDurationMins change
}
/*
  Since PumpStatusT is READ_WRITE variable, onPumpStatusTChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPumpStatusTChange()  {
  // Add your code here to act upon PumpStatusT change
}
/*
  Since FanSwitch is READ_WRITE variable, onFanSwitchChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onFanSwitchChange()  {
  // Add your code here to act upon FanSwitch change
}


/*
  Since DueReset is READ_WRITE variable, onDueResetChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDueResetChange()  {
  // Add your code here to act upon DueReset change
  digitalWrite(RESET_PIN_Due, LOW);
  delay(1000);
  digitalWrite(RESET_PIN_Due, HIGH);
}

/*
  Since LightStatus is READ_WRITE variable, onLightStatusChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLightStatusChange()  {
  // Add your code here to act upon LightStatus change
}